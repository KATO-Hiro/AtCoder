# 鉄則本

- 現状: 緑diff下位の問題なら解ける可能性がある。苦手系だと茶色上位でも怪しい。
- 目標: ABCの水色下位diffの問題が30〜45分で解けるようになる
  - 考察力を高める
  - コーナーケースを見つけられるように
- 何を重点的に学ぶか?
  - 二次元累積和
  - 尺取り法
  - 半分全列挙
  - DP
  - ビットDP
  - 余りの計算
  - 包除原理
  - ゲーム
  - 考察テクニック
  - 深さ優先探索
  - 木に対するDP
  - 演習・総合問題
    - 星3〜4を埋める

## xxx

-
- 

## 018

- 部分和問題、DP

- dp[i][j]: i番目を選んだときに、合計をjにできるか?

```py
dp = [False] * (s + 1)
dp[0] = True

for ai in a:
    # 逆順に回すのがポイント
    # 配列を使い回す
    for i in range(s, 0, -1):
        if i - ai < 0:
            break

        dp[i] |= dp[i - ai]
```

## 031

- 整数、割り切れる数、組み合わせ、和集合

- 3で割り切れる数 + 5で割り切れる数 - 15で割り切れる数

## 065

- グラフ理論、木、木に対するDP

- 解説AC
- 実装が難しいと感じた問題
  - 親子関係を問題の制約から読み取る
  - 葉から考える
    - DFSだと思ったが、人数の更新の部分がうまく考察できず
  - 親子関係の性質から、nが大きい順に計算する
- 番号の制約がない場合は、BFSで頂点1から頂点xまでの最短経路長dist[x]を計算して、値が大きな頂点から計算する、もしくは、DFSで。

```py
    graph[ai].append(i)

    for i in range(n - 1, -1, -1):
        for j in range(len(graph[i])):
            k = graph[i][j]
            dp[i] += dp[k] + 1      

    # DFSによる解法
    def dfs(cur):
        for to in graph[cur]:
            dfs(to)
            ans[cur] += ans[to] + 1

    dfs(1)
```

- 部下→上司の方向に辺を追加すると思ったが、誤読か?
