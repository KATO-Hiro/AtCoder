# 典型90問

|001-010|△|◯|◯|◯|--|△|◯|△|--|◯|
|011-020|--|△|◯|◯|--|△|--|--|--|◯|
|021-030|△|◯|--|◯|--|△|◯|△|--|△|
|031-040|--|◯|△|◯|--|◯|△|◯|△|--|
|041-050|--|△|△|--|◯|--|◯|--|△|--|◯|
|051-060|△|◯|--|--|△|△|--|△|--|△|
|061-070|◯|--|△|△|--|△|◯|--|◯|△|
|071-080|--|△|--|--|◯|△|--|◯|△|--|
|081-090|△|◯|--|△|◯|△|--|--|--|--|

## 001

最小値の最大化、答えを決め打ちして二分探索、貪欲法、問題文の言い換え

- 問題文を見た瞬間に、答えを決め打ちして二分探索する問題だと分かった
- 判定部分の考察&実装がうまくできなかった
  - 長さを決めたときに、区切る位置を全探索
  - 判定条件のうち、L - A[i]がM以上となる、が抜けていた
  - K+1個に分割するところが、K+1個以上になって良いところが分かっていないかも

- 長さM以上→K+1個のピースがそれぞれ長さM以上に分割できるか?
- Yes/No判定
  - K個ちょうどではなく、K以上

- 上位陣の提出解法
  - L - A[i]がM以上のチェックがないケースもある
  - Yes/No判定がK個より大きいかどうか

## 002

- bit全探索、文字列

- ()の判定
  - (と)が同数
  - (の数が常に)以上
    - 実装は+1、-1でカウントすると楽

## 003

グラフ、木構造、木の直径

- グラフの問題に帰着
  - 頂点uから頂点vに行く単純パスはただ一つ
  - 頂点uと頂点vを双方向に結ぶ辺を1本追加すると、閉路が1つだけ出現する
    - 長さは、u→vの単純パスの長さ + 1
- 木の直径: 単純パスの長さの最大値(最短距離の最大値)
  - 最短距離の計算を2回行う
    - 頂点1から各頂点までの最短距離を求める
    - 最短距離が最も大きい頂点から、各頂点への最短距離を求める
      - そのときに、最短距離が最大となる値が答え
- 計算量はO(N)

## 004

累積和、包除原理

- 90度回転させるのに手間取った 

## 006

- 文字列、部分列、辞書順最小、前から貪欲に決める、前計算による高速化

- 考えたこと
  - 辞書順最小に関する問題は、前から決めるといい場合が多い
  - 制約の小さい部分に着目すると、文字は26種類しかない
  - DPを使うなら、後ろから決める or 経路復元が必要?
  - naiveなDPだと、O(NK)となるため、配列を使い回す必要がある

- できなかったこと
  - 貪欲的なアプローチで文字を決める、という正当性の証明
  - 文字数がK文字となるかどうか
    - 「前選んだ文字の右にある文字cの中で最も左にあるもの」以降を全部選んでK文字以上にする
    - 上記の処理を前計算することで、O(1)にできる

- 得られた知見
  - 作れる文字のうち、1文字目が'a'に近い
    - 2文字目が'a'に近い
    - 3文字目が(ry
    - 以降、同様
    - つまり、次の文字としておける最も'a'に近い文字を貪欲的に付け足すことを繰り返すことで、答えが得られる
  - 文字を置くことができる条件
    - 前に選んだ文字の右にある文字のうち、最も左にあるもの以降すべてを選んでK文字以上になる
  - 上記の条件を全探索するとO(|S|)かかる
    - 配列を前計算することで、O(1)にできる
    - 文字の後ろから累積的に計算
    - c[i][j]: i文字目の右にある文字jのうち、最も左側にあるインデックス(何文字目か?)

- 疑問点
  - ステップ1を自力でコードに落とし込むことができるか?と言われるとかなり怪しい
  - 実装で、ステップ1と2の関連が分かっていないのでは?
    - A: 現在の位置と前計算したインデックスとの関係から、次の位置を計算
      - 長さがK以上なら、答えに文字を追加&現在の位置を更新

- 抽象化
  - 辞書順最小に関する問題は、貪欲法のアプローチがうまくいくことが多い
  - 少し緩い条件を考える
  - 前計算により高速化を図る
    - 例: 全探索をする代わりに、累積的なアプローチを用いる

## 007

数列、要素の検索、ソート、二分探索

- 一致する要素や最も近い要素の検索には、二分探索を使うと高速に動作する
  - 昇順/降順?になっている必要がある

- ABC212C問題とほぼ同じ
  - 制約条件より小さい/大きい値を入れておくと範囲外参照の処理をしなくて済む

## 008

文字列、部分列、DP、状態DP、組み合わせ、数え上げ

- ABC211で、ほぼそのまま出題されていた
- 状態: dp[調べたい文字列の位置][作りたい文字列のうち、何文字目まで使ったか]: 該当する組み合わせの数
- 遷移:
  - i + 1文字目を選ばない
    - dp[i + 1][j] += dp[i][j]
  - i + 1文字目を選ぶ
    - dp[i + 1][j + 1] += dp[i][j]
    - 調べている文字が作りたい文字列に含まれているか?
    - 調べている文字列のインデックスが妥当か?
- 求める答えは、dp[n][作りたい文字列の長さ]
- 解説では二次元配列で管理されているが、AC解法を見ると一次元配列で計算されている
  - 「調べている文字列の位置」を状態として持たなくて良い
  - 状態: dp[j] 作りたい文字列のうち、j文字目まで使った
  - 遷移: dp[j + 1] += dp[j]、現在見ている文字と作りたい文字が一致しているとき

## 010

累積和

- クラスidと生徒idを誤読していた

## 012

グリッド、連結判定、データ構造、UF、Union Find

- UFでクエリを処理すれば良いのは、割とすぐに気がつけた
  - グリッドに対しても、同様の考え方ができる
- 実装をミスったせいか、サンプルと永遠に合わないのを繰り返していた
  - 頂点番号ではなく、(r, c)のペアを擬似的に一つの値に変換するところで、インデックスを間違えていたっぽい
  - 縦方向と横方向の添え字を間違えていたかも

https://atcoder.jp/contests/typical90/submissions/21910765

## 013

グラフ理論、無向グラフ、最短経路、コストの最小化、経由、右端・左端から計算

- ある頂点から任意の頂点までの最短距離は、ダイクストラ法で計算できる
- 頂点kを経由する場合は、頂点1→kと頂点k→nに分解
- 無向グラフなので、n→kと言い換えても差し支えない

## 014

数列、ソート、貪欲法、ソートしてから貪欲法、Greedy

- 証明なしのGreedyで通してしまった
  - あえて、Greedyが成り立たない条件にして、コストを小さく/価値を大きくできるか?

## 016

工夫した全探索

- ちょうど◯枚でN円という問題文から、dpかと思ってしまった
  - dpの漸化式を立てられず

- 無駄に計算しているところがないか?
- 複数の変数のうち、導出できる変数がないか?

## 020

対数、小数、整数

- 誤差に注意

## 021

- グラフ理論、無向グラフ、強連結成分分解、SCC、SCCを行うとDAGになる

- 考えたこと
  - 双方向に到達可能な頂点の組を取り出す
  - 上記の頂点をUFでまとめる
  - 親となる頂点のケースに対して、そのグループのサイズをsとしたときに、s(s - 1) / 2を計算する
    - 上記のケースを全頂点に対して計算&合計

- できなかったこと
  - 半分くらいのケースでWAだった
    - サイクルが含まれているパターンを考慮できていなかったかも
  - 強連結成分分解を初めて知った

- 得られた知見
  - 強連結
    - 有向グラフに対して、頂点x,yが互いに到達可能である
    - どのような有向グラフでもグループ分けが可能
  - 強連結成分分解
    - 計算量O(N + M)
    - 1. DFSで帰りがけ順に番号を記録
    - 2. 辺の向きをすべて反転させてから、番号の大きい順にDFS
  - SCCの活用方法
    - 同じグループの頂点を一つにまとめると、サイクルを含まないDAGになる
    - 上記の性質を利用する問題もある

## 022

最大公約数、ユークリッドの互除法

- 立方体は、全ての辺の長さが等しい
- 3変数の最大公約数gを求める
- 各辺をgで割り、-3する
  - 立方体となるように切る(辺の長さがgと一致していれば切る必要がない)

## 024

数列、操作によって2つの数列を一致させる、パリティ

- n = 1のときに着目
- 操作によって、偶数と奇数が交互に

- 条件1: |数列Bと数列A|がK以下
- 条件2: Kが偶数なら、AとBの偶奇が同じ
　　　　　Kが奇数なら、AとBの偶奇が異なる

- n個の場合も同様

## 026

グラフ、木、彩色問題、二部グラフ

- 二部グラフ
  - 辺で直接結ばれた頂点同士が互いに違う色になるように、頂点を2色で塗ることができる
  - 性質
    - 奇数長の閉路を含まない
    - 最大マッチングが多項式時間で計算できる
- 木は必ず二部グラフ
- 2色で塗ったときに、少なくとも片方がn // 2個以上の頂点を占める
  - 頂点数の多い方のうち、n // 2個を出力すればよい
- 全体計算量はO(N)
- この問題では、取り出す頂点の数が最大となる構成(最大独立集合)も計算できる

- 実装
  - dfs
  - 引数は、現在の頂点番号、現在の色
  - 頂点の色を0, 1で管理
  - まだ塗っていない場合に、1 - curで色を塗る

- dfsで頂点番号をリストに追加
  - 引数: 現在の頂点番号、親の頂点番号、頂点番号のリスト、直前の頂点を使ったかどうか
  - 4WAが取れず
    - N // 2個未満場合を見逃していたと思われる
  - 想定例だと引数もかなりシンプル

## 027

データ構造、辞書、重複の確認

- set()でも同様の処理ができる

## 028

累積和、二次元imos法

- グリッドの左下と右上に+1、左上と右下に-1する
  - 本家の解説だと逆になっていて混乱した
- 添字ミスにより2WA
  - グリッドの大きさを少し大きめに取り、1-indexで扱ったほうがいいのか?
  - 上下反転しているのを見逃していた

https://imoz.jp/algorithms/imos_method.html

## 030

- 素因数、数え上げ、エラトステネスの篩、約数列挙

- 素因数を列挙するときに、同時に各値の素因数の個数を計算

## 032

順列全探索

- 制約から解法を推察
- dfsで枝刈りしないとTLEすると思っていたが、permutationsで十分に間に合った

- 制約が小さいときは、N!も間に合う
- 走者の順番をメモしておく

## 033

コーナーケース

- h/2とw/2を切り上げて、それらの積を取る
- コーナーケースに見事にハマった
  - 行か列が1マスなら、連続してLEDを点灯できる
  - 2 * 2の領域で2以上LEDを点灯させてはいけない
  - 1 * 1の領域なら、上記の条件を満たさない

- コーナーケースを考慮しようとすると、複雑な実装をしがち
- コーナーケースへの対処方法
  - 答えの上限/下限を考えて、実現できる構成を考える
  - 小さいケースで実験する

## 034

単調性、尺取り法

- 値の種類数に単調性
- dequeを利用して実装

- この問題だけかもしれないが、delを使っても間に合った
  - delを使うと重いイメージがあったため

## 036

クエリ処理、マンハッタン距離、頂点間の最大値、45度回転、座標変換

- 点P(x, y)とのマンハッタン距離がK以下の領域を考える
  - 全点の座標を45度回転させる
  - 座標を変換した後で、距離の最大値を計算
    - 差分を取るときは、絶対値を取る
- 計算量は、O(N + Q)

## 037

ナップザック問題、価値の最大化、動的計画法、DP、データ構造、RMQ、セグメント木、高速化

- ナップザック問題
  - 状態: dp[i][j]: i個目まで見て、香辛料の重さがjのときの価値の最大値
  - 遷移: 香辛料を選ぶ/選ばない
    - dp[i][j] = max(dp[i - 1][j - ri], ..., dp[i - 1][j - li]) + vi
    - dp[i][j] = dp[i - 1][j]
  - 計算量: O(N * W ** 2)
- 高速化
  - ボトルネックとなっている部分を特定
  - 区間の最大値を求める部分が遅い
  - 有名問題に帰着させる(今回は、RMQ)
  - セグメント木を使う
    - 数列Aに対するクエリを高速に処理できる
    - 処理1: x, yが与えられたときに、Ax = yに変更
    - 処理2: l, rが与えられたときに、max(Al, ..., Ar)の値を出力
  
- ボトルネックとなっている処理を特定
- 有名問題に帰着させる
  - 欲しい性質を列挙
  - 該当するデータ構造を活用
- 区間の処理を高速に行う方法の一つにセグメント木がある

## 038

最小公倍数、オーバーフローに注意

- 多倍長整数が扱えるPythonの自作関数で殴った
- オーバーフローに注意

## 039

グラフ理論、木、最短距離、答えへの貢献度を考える、DP、主客転倒、木DP

- 頂点1を根とする根付き木を考える
- 最短経路そのものを数えるのではなく、ある辺が何個の頂点対における最短経路に含まれるか?
  - ある辺の「答えへの貢献度」を考える
- 各辺の貢献度を定式化
  - ある頂点から派生している頂点(ある頂点も含む)のグループAと、それ以外のグループBに分ける
  - u, vが違うグループに属する場合に、着目した辺を最短経路に含む
  - グループAに属する頂点数を|A|とすると、着目した辺の答えへの貢献度は|A| * (N - |A|)
- ある頂点xから派生している頂点の個数の求め方(y1, y2, ..., ykは、辺で直接繋がっている頂点)
  - dp[x] = dy[y1] + dy[y2] + ... + dy[yk] + 1
  - dfsで求めることができる

```py
def dfs(pos, parent):
    dp[pos] = 1

    for v in graph[pos]:
        if v == parent:
            continue

        dfs(v, pos)
        dp[pos] += dp[v]
```

- 最短経路そのものではなく、ある辺が最短経路に含まれる数に注目
- 主客転倒
  - シグマの計算を高速化するのに有用
- 木を自身から派生するグループと、それ以外のグループに分ける

## 042

倍数の性質、剰余、mod、数え上げ、動的計画法、DP

- N mod 9 = Nの各桁の数字の和 mod 9

- k mod 9 != 0: 0通り
- k mod 9 = 0: 各位の数字の和がKである正整数の個数
  - dp[各桁の数字の和] = 組み合わせ数
    - dp[0] = 1
    - dp[i] = dp[i-1] + dp[i-2] + ... + dp[i - 9], (i = 1, 2, ..., K)
    - i: 1, 2, ..., K
    - j: 1, 2, ..., min(i, 9)
    - dp[K]が答え
    - modを取る必要がある
  - 1〜9からなる各桁の数字の和がKのの整数は、先頭の桁の和1〜9それぞれの場合が分岐するため

- dp
  - 状態: 桁の数字の和そのもの
  - 遷移: 1〜9が加算される=桁の数字の和-1〜桁の数字の和-9を足したものと等しい

- 倍数の性質
  - 2の倍数: 1の位が0, 2, 4, 6, 8
  - 3の倍数: 各桁の数字の和が3の倍数
  - 4の倍数: 下2桁が4の倍数
  - 5の倍数: 1の位が0, 5
  - 8の倍数: 下3桁が8の倍数
  - 9の倍数: 各桁の数字の和が9の倍数
  - 11の倍数: 奇数桁目の数字の和 - 偶数桁目の数字の和が11の倍数

感想

- 倍数の性質を理解している必要がある
- DPとしては、とてもシンプルだが思いつかなかった
  - シンプルなDPだと、求める答えそのものが状態になることがある
- このようなDPが自然に書けるようになりたい

## 043

グリッド、最短経路問題、コストの最小化、コストの有無、拡張BFS・ダイクストラ、01-BFS

- 単純な最短経路問題ではなく、方向転換の回数を最小にしないといけない
- マスの進み方
  - 1. 現在と同じ向き(コスト0)
  - 2. 現在と異なる向き(コスト1)
- スタートからゴールまでの合計コストを最小化する
- 各マスに対して4種類の最短経路を記録
  - dist[i][j][0]: 上を向く状態までの方向転換の回数の最小値
  - dist[i][j][1]: 右を向く状態までの方向転換の回数の最小値
  - dist[i][j][2]: 下を向く状態までの方向転換の回数の最小値
  - dist[i][j][3]: 左を向く状態までの方向転換の回数の最小値
- 01-BFS(O(HW))やダイクストラ法(O(HWlogHW))で解ける

### できたところ、できなかったところ

- ◯: BFSで最短経路を探索する
- △: 方向転換によるコストを管理する
  - ◯: 方向の管理と直前の移動方向が一致しているかどうかを管理
  - ×: 4方向の移動回数の最小値を直接配列として管理
- 01-BFSを聞いたことはあったが、十分身についていなかった

### 実装のコツ

- 3次元配列を取る
  - dist[x][y][dir]: x, y座標、dir方向に移動するときの移動回数の最小値
- 01-BFS
  - 方向が一致: 先頭に追加
  - 方向が違う: 末尾に追加
  - コストを小さくできる場合のみ、座標を追加

#### Pythonの場合

- 解説の通り愚直に3次元配列を使って実装するとTLEする
- dequeでコストも管理する
- コストの更新条件
  - 方向転換なし: コストが現状のマスのコスト以下なら更新
  - 方向転換あり: コストが現状のマスのコスト未満なら更新

https://atcoder.jp/contests/typical90/submissions/22715442

### 抽象化

- 各頂点の持つ情報を拡張して状態を管理する

### 感想

- 3次元配列は遅くなる印象
- コストの更新条件の境界値の考察できていなかったので無限にWAやTLEを量産してしまった
  - 手癖で大きな方針が間違っているのに小手先の修正でなんとかしようとしている

## 044

クエリ処理、見かけの変化を記録、高速化

- prd_xxxさんのO(1)でアクセスできるdequeを使った

- 重いクエリの処理を元の配列のままの状態で考えることで計算量の削減を図る
  - 位置関係は変わらない
  - 操作後の位置が元の配列で、どこに対応するかを換算
    - 換算をバグらせそう
      - shiftした回数 = (shiftした回数 + n - 1) % n
      - (現在の位置 + shiftした回数) % n

## 046

整数、整数の和、数え上げ、剰余、同じ意味・状態のものをまとめる、頻度分布、候補を絞って全探索

- 整数xで割った余り ⇆ xの倍数
- 巨大な数に対して、余りを取っても言い換え前後の内容は等価
- mod xがいくつあるか数える
- xが小さい場合は全探索できる

- 偶奇を問われる問題にも応用できる

- modを取り、頻度分布をまとめる & modを取る値が小さければ全探索可能

## 048

答えの上限下限を見積もる、単位を揃える、貪欲法

- DPかと思っていた

- 1分使うことで得られる得点
  - 部分点を取っていない問題を解いて、Bi点を得る
  - 部分点を取った問題を解いて、Ai - Bi点を得る
- 同じ手段を2回以上選べないので、上記の得点を降順にして、K番目までの要素の和

- 異なる単位で増減する場合は、単位を揃える
- 同じ方法が選べるかどうか
  - 同じ方法が選べない場合は、昇順や降順にする
- 上限を見積もる
  - そのまま答えとなる場合や方法を構成することができる
  - 選べる手段の中で、最も良いものを選ぶ

## 050

動的計画法、DP、漸化式、部分問題、典型

- 今回は、配るDPかつ配列を大きめに取ることでインデックスの参照外を防ぐようにした

- 貰うDP
  - dp[0] = 1
  - dp[i] = dp[i - 1] (1 <= i < L)
  - dp[i] = dp[i - 1] + dp[i - L] (i >= L)

## 051

数列、半分全列挙、全探索、二分探索、データを分割&再結合

- グループを均等に分ける

## 052

算数、総和、因数分解、高速化、典型

- 因数分解で表現できる
- 小さなケースで考える(ex: N = 2)
  - 上記の考察から得られた方法をN >= 3のケースに対しても考える
- 約数の個数、総和にも応用できる
- 条件式を因数分解して、計算しやすい形にすることもできる

- 各サイコロについて総和を取り、それらの積 % mod
- サンプルN >= 3のケースでWAを確認して修正
  - nC2と思っていた

## 055

組み合わせ、数え上げ、定数倍、典型

- O(N ** 5)解法が通る
  - 定数倍が1/120
  - 定数倍が軽い場合は通る可能性がある
    - PyPyの場合は、5.0 * 10 ** 7まで
    - 制限時間が5sなら、1回あたりの計算がとても軽ければ10 ** 8も可能な場合がある
- modを適宜取る工夫が必要
  - 多倍長整数が扱える言語でも2 ** 63 - 1を超えると遅くなる

```py
    # TLE
    # combinationsで生成すると遅い
    for i, j, k, l, m in combinations(a, 5):
        number = i * j
        number %= p
        number *= k
        number %= p
        number *= l
        number %= p
        number *= m
        number %= p

        if number == q:
            ans += 1
```

## 056

DP、判定問題、DP復元、経路復元、復元は後ろから順番に

- 問題の条件を満たすかを判定する
  - dp[i][j]: i日目までにj円にできるか?(True/False)
    - 初期化: dp[0][0] = True
    - 遷移: d[i - 1][j - a[i]]かd[i - 1][j - b[i]]のどちらかがTrueならdp[i][j]はTrue
  - 計算量はO(N * S)
- 答えの復元方法
  - 逆順に計算
  - N日目から考える
    - dp[N - 1][S - An] = Trueなら、Aを選んで良い
    - dp[N - 1][S - Bn] = Trueなら、Bを選んで良い
  - 実装
    - 残りの金額を保持する変数を用意
    - 上記の値がAi/Biよりも大きく、dp[i - 1][S - Ai/Bi] = Trueなら、A/Bを答えに加える
  - 最短経路問題の復元にも利用できる

- いきなり定式化するのが難しい場合は、一つのケースで試す
- 復元は、最後の結果から順番に見る

## 058

周期性、剰余、桁和、小さなステップに分解、実装力

- 周期性を利用して、Kが大きい場合でも高速に求める、という全体の方針はすぐに思いついた
- 各ステップに分解できなかったため、実装ができなかった
  - 値がxのときに、次の値がいくつになるかを前計算する
  - ループを検出する
    - リストを-1で初期化
    - リストである値を使ったどうかを管理
    - リストのある値が-1以外ならループに到達したため、打ち切る
  - 周期の長さを求める
    - ループ回数と、ループが終了したときの位置の差
  - 周期の長さを利用して、半端な部分K'を求める
  - K'回のときの値を全探索する

```py
# -*- coding: utf-8 -*-


def digit_sum(n):
    summed = 0

    while n > 0:
        summed += n % 10
        n //= 10

    return summed


def main():
    import sys

    input = sys.stdin.readline

    n, k = map(int, input().split())
    mod = 10 ** 5

    next_pos = [0] * mod

    # 前計算: 値xのときに、次の値がいくつになるか?
    for x in range(mod):
        y = digit_sum(x)
        z = (x + y) % mod
        next_pos[x] = z
    
    histories = [-1] * mod
    cur_pos, count = n, 0

    # 2周目となる最初の値を検出
    while histories[cur_pos] == -1:
        histories[cur_pos] = count
        cur_pos = next_pos[cur_pos]
        count += 1
    
    # 周期を求める
    cycle = count - histories[cur_pos]

    # 周期+αのαを求める
    if k >= histories[cur_pos]:
        k = (k - histories[cur_pos]) % cycle + histories[cur_pos]

    # α回押したときの整数を求める
    for i in range(mod):
        if histories[i] == k:
            print(i)
            exit()


if __name__ == "__main__":
    main()

```

## 060

数列、部分列、最長増加部分列、LIS、前計算

- シンプルな数列を例に、最長増加部分列を求める
  - O(NlogN)
- 前計算
  - 左右両側からLISを求める
  - 上記の長さの和 - 1
- ある位置を決めて全探索

- 簡単な問題を考える
- 両側から考える
  - 3個の要素を扱うときは、中央の2個を考える

## 063

制約条件から逆算、小さな値を全探索、行列を分けて考える、頻度を管理

## 064

階差(隣り合う2つの要素の差)、変化量に着目、最初の1回は全探索 + 残りのクエリは差分を計算

- 隣接区画している標高差に関心がある
  - Bi(区画i + 1の標高 - 区画iの標高)を考える
  - Σ|Bi| i = 1, 2, ..., N - 1
- LからRまでの標高がV増えたときに、Biの変化量は
  - BL-1が+V
  - BRが-V

- 実装でもインデックスでかなりハマった
  - prd_xxxさんの実装がとても参考になった
    - bの両端に番兵として、0を入れておく 
    - 左右のインデックスが範囲内のときだけ、答えが変化する
    - 操作前の値を引いておき、操作を行う、操作後の答えを加算 

- 1回目は全探索 + 2回目以降は、その差分を計算する
- 隣接している部分にしか影響が及ばないことに着目する
- インデックスの参照外エラーを回避するため、条件分岐

## 066

数学、期待値、転倒数、期待値の線型性

- 一つのケースだけなら、:w転倒数=BIT
- 期待値の線型性がありそう
- DPで管理?
  - dp[i][j]: i番目の要素を見たときに、jとなる要素のパターン数

- 期待値の線型性
  - Xの期待値 + Yの期待値 = X + Yの期待値
  - 要素が3個以上の場合についても一般化して考えることができる
  - 「和の期待値は期待値の和」
    - 確率変数が独立でなくても成立する
  - 確率変数がすべて独立である場合は、「積の期待値=期待値の積」も成立する

- 期待値の線型性を具体的にどう適用するか?
  - Xi > Xjとなる確率をEi,jとするとき、「XiとXjの関係が転倒数に寄与する分の期待値(貢献度の期待値)」はEi,j
    - ans = (E1,1 + E1,2 + ... + EN-1,N) = ΣΣEi,j (i=1,2,...,N, j=i+1,2,...,N)
  - 制約が小さいのでEi,jは全探索で計算できる

- 貢献度を考える

## 067

N進法展開、N進数

- 8進数から9進数に直接変換するのは難しい
  - 8進数→10進数→9進数と処理
- bit全探索やbitDPにも応用できる

```py
# 8進数への変換
int(n, 8)

# 8進数に変換(数値→文字列)、プレフィックスに"0o"が付く
oct(n)
```

https://docs.python.org/3/library/functions.html#oct

## 069

色の塗り分け方、数え上げ、剰余、繰り返し二乗法、典型

- 最初はK色塗ることができる
- 次は、K-1色(ry
- それ以降は、K-2色(ry...
- Pythonではpowを使う
  - 内部的にa ** b mod pを繰り返し二乗法で処理

- 添字や指定範囲のミスで3WAもしてしまった

- 問題を単純化
  - 累乗や二項係数を使う

## 072

総パターン数を見積もる、再帰関数、バックトラック

- 再帰関数の実装がポイント
  - 状態を変数として持つ
  - 再帰呼び出し
  - 移動ができなくなった場合に一つ手前に戻る

## 075

整数、素因数分解、操作回数の最小値

- 素因数分解
- 回数のカウント
  - 最初、ceil(sqrt())という変なことをしていた
  - 2 ** ans > 素因数分解したべき乗?の数の和
    - 部品が2つずつに分かれていくことから
- コーナーケース
  - 素数の場合は、0回

## 075

x, y軸を独立に考える、絶対値の総和の最小値、中央値を利用すると絶対値が最小に

- 発電所の座標をどこにするか?
  - mean or median
- 重複する場合は除外する?
- 整数で出力していなかった

- x, y軸の計算は独立に考えられる
- 各軸の値を計算
  - 変化量に着目する
    - f(a) = |X1 - a| + |X2 - a| + ... + |Xn - a|
    - aを+1ときの変化量は、aよりも左側にある点の個数 - aよりも右側にある点の個数
    - 左側の方の点が多いとき、左側に動く
    - 右側の方の点が多いとき、右側に動く
  - aがXの中央値のとき、絶対値の総和が最小となる

```py
    from statistics import median

# -*- coding: utf-8 -*-


def main():
    from statistics import median
    import sys

    input = sys.stdin.readline

    n = int(input())
    x = list()
    y = list()
    
    for _ in range(n):
        xi, yi = map(int, input().split())
        x.append(xi)
        y.append(yi)
    
    x_median = median(x)
    y_median = median(y)

    ans = 0

    for xi, yi in zip(x, y):
        ans += abs(x_median - xi) + abs(y_median - yi)
    
    print(int(ans))


if __name__ == "__main__":
    main()

```

## 076

整数、円環、言い換え、円環を1列に切り開いて二倍、二分探索、尺取り法

- 部分和問題→DPかと思ったが、連続する区間と書かれていたので方針変更
- 円環を切り開いて、末端を先頭にくっつける&尺取り法で数列を管理
  - 尺取り法は、dequeを使うと添字をバグらせにくいという記事を見て実装した

- 5WAが取れず
  - 単に1箇所だけ例外処理をしていただけだった
  - 2周分試したらACした

- 円環を切り開いて列として扱う
  - 二倍すると、端部を楽に処理できる
- Br - Bl = Bn / 10となる位置を二分探索
  - bisectを使った二分探索は、バグを埋め込みやすく敬遠しがち
- コーナーケース
  - 端部を含み、その区間がかなり長い場合

## 078

グラフ、隣接行列、隣接リスト

- 頂点数の分だけ配列を用意
- 頂点ai > biのときはai +=1、bi > aiのときはbi += 1
- 頂点ごとに該当する個数が1つのときだけans += 1

- リストに対してもcount()が利用できるらしい

## 079

最小操作回数、操作順に依存しない

- 最終的な結果が操作の順序に依存しないため、左上から順に操作する
- Yes/Noの判定
  - A11は、(x, y) = (1, 1)の操作でしか変えられない
  - (1, 1)の要素をvとすると、以下のように操作
    - v > 0: |v|回だけ「1減らす操作」
    - v < 0: |v|回だけ「1増やす操作」
  - A12は、(x, y) = (1, 2)の操作でしか変えられない
  - 上記の操作を繰り返す
  - 残りのH + W - 1個の要素が一致するか判定すれば良い
- 上記の判定の際の操作回数が最小操作回数になる
  - (x, y) = (i, j)の変化させる値が一意に定まるため

## 081

データを二次元にプロット、二次元累積和、最小値を全探索、包除原理

- 生徒の身長と体重を二次元の座標orマスにプロット
- チームの最小の身長h_minと体重w_minとすると、チームに含まれる生徒の条件は
  - h_min <= h' <= h_min + k
  - w_min <= w' <= w_min + k
- 長方形領域の総和が最適解
- 上記の計算は、二次元累積和を使うとO(1)で計算できる
  - 行、列でそれぞれ累積和を取る
  - 包除原理により、Prxry - Plx-1ry - Prxly-1 + Plx-1ly-1 で計算できる
- 1 <= a, b <= 5000の範囲を全探索
- 全体計算量は、O(N + max(A)・max(B))

- データを二次元にプロット
  - データ構造を扱う問題やクエリ処理の問題でも有効
- 累積和は、次元を拡張できる

## 082

数列、数列の和、部分問題に分解

- 桁ごとに分解
- 右端 - 左端を求める
  - f(min(r, 10 ** i - 1)) - f(max(l, 10 ** i))
- n * (n - 1) // 2

- 数列の和
  - 1 ** 2 + 2 ** 2 + 3 ** 2 + ... + n ** 2 = n * (n + 1) * (2 * n + 1) // 6
  - 2 ** 0 + 2 ** 1 + ... + 2 ** n - 1 = 2 ** n - 1
  - 1 + p + p ** 2 + p ** 3 + ... = 1 / (1 - p) (0 < p < 1)

## 084

組み合わせ、数え上げ、ランレングス圧縮、余事象、累積和

- 条件を満たす個数を求めるのが難しい/計算量が多い場合は、条件を満たさない個数を数える
  - 全体 - 条件を満たさない個数
- 同じものはまとめる
- 区間[l, r]の選び方は、1 + 2 + 3, ..., n = n * (n - 1) / 2

## 085

約数、組み合わせ、数え上げ、約数列挙、工夫した全探索

- a, b, cは、Kの約数である
- 約数の個数は、思ったより少ない
  - 10 ** 6以下: 240個
  - 10 ** 9以下: 1344個
  - 10 ** 12以下: 6720個
  - 10 ** 18以下: 103680個
- 約数の列挙
  - √kの範囲で k % i == 0のとき、i とk // iが候補
  - setなどで重複を除去する
- a, bが決まれば、cは一意に定まる
  - c = k // (a * b)

- 約数の個数が10 ** 3程度だと思っていたが、10 ** 9のケースだった
- 列挙した約数をソート&bがaよりも大きい値のみをチェックすることで、高速化を図れる

## 086

整数、数え上げ、OR、bit(桁)ごとに独立に考える、bit全探索、部分問題に分解&合成

- x OR y OR z = wをbit(桁)ごとに考える
  - (xの2 ** iの位) OR (yの2 ** iの位) OR (zの2 ** iの位) = wの2 ** iの位
  - i: 非負整数Xを2進数で表現したときにしたからi + 1桁目を表す
- Ax[i] OR Ay[i] OR Az[i] = W[i]を満たす条件を言い換える
  - W[i]の2 ** jの位をWi,j、A[i]の2 ** jの位をai,jとすると、各条件(最大59程度)は独立に考えることができる
- 条件を満たす組みあわせは、「場合の数の積」で求めることができる
  - 条件1の組み合わせ * 条件2の(ry * ... * 条件nの組み合わせ
- bit全探索の問題に帰着させる
- 計算量は、O(g * 2 ** n * (n + q)) = 1.5 * 10 ** 7
  - グループ数: g = 60
  - パターン数: 2 ** N通り
  - 2進数への展開: O(N)
  - 全ての条件を満たすかを判定: O(Q)

- 難しい問題も典型的な要素の組み合わせになっている場合がある
- 部分問題に分解して、最後にまとめる
- 貢献度を考える
