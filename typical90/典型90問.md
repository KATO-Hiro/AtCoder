# 典型90問

|001-010|△|--|◯|◯|--|--|◯|△|--|◯|
|011-020|--|△|--|◯|--|△|--|--|--|◯|
|021-030|--|◯|--|◯|--|--|◯|--|--|--|
|031-040|--|◯|△|◯|--|--|--|◯|--|--|
|041-050|--|-:w-|--|◯|--|◯|--|△|--|◯|
|051-060|--|◯|--|--|△|--|--|--|--|--|
|061-070|◯|--|--|--|--|--|◯|--|◯|△|
|071-080|--|--|--|--|◯|△|--|◯|△|--|
|081-090|--|◯|--|△|◯|--|--|--|--|--|

## 001

最小値の最大化、答えを決め打ちして二分探索、貪欲法、問題文の言い換え

- 問題文を見た瞬間に、答えを決め打ちして二分探索する問題だと分かった
- 判定部分の考察&実装がうまくできなかった
  - 長さを決めたときに、区切る位置を全探索
  - 判定条件のうち、L - A[i]がM以上となる、が抜けていた
  - K+1個に分割するところが、K+1個以上になって良いところが分かっていないかも

- 長さM以上→K+1個のピースがそれぞれ長さM以上に分割できるか?
- Yes/No判定
  - K個ちょうどではなく、K以上

- 上位陣の提出解法
  - L - A[i]がM以上のチェックがないケースもある
  - Yes/No判定がK個より大きいかどうか

## 003

グラフ、木構造、木の直径

- グラフの問題に帰着
  - 頂点uから頂点vに行く単純パスはただ一つ
  - 頂点uと頂点vを双方向に結ぶ辺を1本追加すると、閉路が1つだけ出現する
    - 長さは、u→vの単純パスの長さ + 1
- 木の直径: 単純パスの長さの最大値(最短距離の最大値)
  - 最短距離の計算を2回行う
    - 頂点1から各頂点までの最短距離を求める
    - 最短距離が最も大きい頂点から、各頂点への最短距離を求める
      - そのときに、最短距離が最大となる値が答え
- 計算量はO(N)

## 004

累積和、包除原理

- 90度回転させるのに手間取った 

## 007

数列、要素の検索、ソート、二分探索

- 一致する要素や最も近い要素の検索には、二分探索を使うと高速に動作する
  - 昇順/降順?になっている必要がある

- ABC212C問題とほぼ同じ
  - 制約条件より小さい/大きい値を入れておくと範囲外参照の処理をしなくて済む

## 008

文字列、部分列、DP、状態DP、組み合わせ、数え上げ

- ABC211で、ほぼそのまま出題されていた
- 状態: dp[調べたい文字列の位置][作りたい文字列のうち、何文字目まで使ったか]: 該当する組み合わせの数
- 遷移:
  - i + 1文字目を選ばない
    - dp[i + 1][j] += dp[i][j]
  - i + 1文字目を選ぶ
    - dp[i + 1][j + 1] += dp[i][j]
    - 調べている文字が作りたい文字列に含まれているか?
    - 調べている文字列のインデックスが妥当か?
- 求める答えは、dp[n][作りたい文字列の長さ]
- 解説では二次元配列で管理されているが、AC解法を見ると一次元配列で計算されている
  - 「調べている文字列の位置」を状態として持たなくて良い
  - 状態: dp[j] 作りたい文字列のうち、j文字目まで使った
  - 遷移: dp[j + 1] += dp[j]、現在見ている文字と作りたい文字が一致しているとき

## 010

累積和

- クラスidと生徒idを誤読していた

## 012

グリッド、連結判定、データ構造、UF、Union Find

- UFでクエリを処理すれば良いのは、割とすぐに気がつけた
  - グリッドに対しても、同様の考え方ができる
- 実装をミスったせいか、サンプルと永遠に合わないのを繰り返していた
  - 頂点番号ではなく、(r, c)のペアを擬似的に一つの値に変換するところで、インデックスを間違えていたっぽい
  - 縦方向と横方向の添え字を間違えていたかも

https://atcoder.jp/contests/typical90/submissions/21910765

## 014

数列、ソート、貪欲法、ソートしてから貪欲法、Greedy

- 証明なしのGreedyで通してしまった
  - あえて、Greedyが成り立たない条件にして、コストを小さく/価値を大きくできるか?

## 016

工夫した全探索

- ちょうど◯枚でN円という問題文から、dpかと思ってしまった
  - dpの漸化式を立てられず

- 無駄に計算しているところがないか?
- 複数の変数のうち、導出できる変数がないか?

## 020

対数、小数、整数

- 誤差に注意

## 022

最大公約数、ユークリッドの互除法

- 立方体は、全ての辺の長さが等しい
- 3変数の最大公約数gを求める
- 各辺をgで割り、-3する
  - 立方体となるように切る(辺の長さがgと一致していれば切る必要がない)

## 024

数列、操作によって2つの数列を一致させる、パリティ

- n = 1のときに着目
- 操作によって、偶数と奇数が交互に

- 条件1: |数列Bと数列A|がK以下
- 条件2: Kが偶数なら、AとBの偶奇が同じ
　　　　　Kが奇数なら、AとBの偶奇が異なる

- n個の場合も同様

## 027

データ構造、辞書、重複の確認

- set()でも同様の処理ができる

## 032

順列全探索

- 制約から解法を推察
- dfsで枝刈りしないとTLEすると思っていたが、permutationsで十分に間に合った

- 制約が小さいときは、N!も間に合う
- 走者の順番をメモしておく

## 033

コーナーケース

- h/2とw/2を切り上げて、それらの積を取る
- コーナーケースに見事にハマった
  - 行か列が1マスなら、連続してLEDを点灯できる
  - 2 * 2の領域で2以上LEDを点灯させてはいけない
  - 1 * 1の領域なら、上記の条件を満たさない

- コーナーケースを考慮しようとすると、複雑な実装をしがち
- コーナーケースへの対処方法
  - 答えの上限/下限を考えて、実現できる構成を考える
  - 小さいケースで実験する

## 034

単調性、尺取り法

- 値の種類数に単調性
- dequeを利用して実装

- この問題だけかもしれないが、delを使っても間に合った
  - delを使うと重いイメージがあったため

## 038

最小公倍数、オーバーフローに注意

- 多倍長整数が扱えるPythonの自作関数で殴った
- オーバーフローに注意

## 044

クエリ処理、見かけの変化を記録、高速化

- prd_xxxさんのO(1)でアクセスできるdequeを使った

- 重いクエリの処理を元の配列のままの状態で考えることで計算量の削減を図る
  - 位置関係は変わらない
  - 操作後の位置が元の配列で、どこに対応するかを換算
    - 換算をバグらせそう
      - shiftした回数 = (shiftした回数 + n - 1) % n
      - (現在の位置 + shiftした回数) % n

## 046

整数、整数の和、数え上げ、剰余、同じ意味・状態のものをまとめる、頻度分布、候補を絞って全探索

- 整数xで割った余り ⇆ xの倍数
- 巨大な数に対して、余りを取っても言い換え前後の内容は等価
- mod xがいくつあるか数える
- xが小さい場合は全探索できる

- 偶奇を問われる問題にも応用できる

- modを取り、頻度分布をまとめる & modを取る値が小さければ全探索可能

## 048

答えの上限下限を見積もる、単位を揃える、貪欲法

- DPかと思っていた

- 1分使うことで得られる得点
  - 部分点を取っていない問題を解いて、Bi点を得る
  - 部分点を取った問題を解いて、Ai - Bi点を得る
- 同じ手段を2回以上選べないので、上記の得点を降順にして、K番目までの要素の和

- 異なる単位で増減する場合は、単位を揃える
- 同じ方法が選べるかどうか
  - 同じ方法が選べない場合は、昇順や降順にする
- 上限を見積もる
  - そのまま答えとなる場合や方法を構成することができる
  - 選べる手段の中で、最も良いものを選ぶ

## 050

動的計画法、DP、漸化式、部分問題、典型

- 今回は、配るDPかつ配列を大きめに取ることでインデックスの参照外を防ぐようにした

- 貰うDP
  - dp[0] = 1
  - dp[i] = dp[i - 1] (1 <= i < L)
  - dp[i] = dp[i - 1] + dp[i - L] (i >= L)

## 052

算数、総和、因数分解、高速化、典型

- 因数分解で表現できる
- 小さなケースで考える(ex: N = 2)
  - 上記の考察から得られた方法をN >= 3のケースに対しても考える
- 約数の個数、総和にも応用できる
- 条件式を因数分解して、計算しやすい形にすることもできる

- 各サイコロについて総和を取り、それらの積 % mod
- サンプルN >= 3のケースでWAを確認して修正
  - nC2と思っていた

## 055

組み合わせ、数え上げ、定数倍、典型

- O(N ** 5)解法が通る
  - 定数倍が1/120
  - 定数倍が軽い場合は通る可能性がある
    - PyPyの場合は、5.0 * 10 ** 7まで
    - 制限時間が5sなら、1回あたりの計算がとても軽ければ10 ** 8も可能な場合がある
- modを適宜取る工夫が必要
  - 多倍長整数が扱える言語でも2 ** 63 - 1を超えると遅くなる

```py
    # TLE
    # combinationsで生成すると遅い
    for i, j, k, l, m in combinations(a, 5):
        number = i * j
        number %= p
        number *= k
        number %= p
        number *= l
        number %= p
        number *= m
        number %= p

        if number == q:
            ans += 1
```

## 067

N進法展開、N進数

- 8進数から9進数に直接変換するのは難しい
  - 8進数→10進数→9進数と処理
- bit全探索やbitDPにも応用できる

```py
# 8進数への変換
int(n, 8)

# 8進数に変換(数値→文字列)、プレフィックスに"0o"が付く
oct(n)
```

https://docs.python.org/3/library/functions.html#oct

## 069

色の塗り分け方、数え上げ、剰余、繰り返し二乗法、典型

- 最初はK色塗ることができる
- 次は、K-1色(ry
- それ以降は、K-2色(ry...
- Pythonではpowを使う
  - 内部的にa ** b mod pを繰り返し二乗法で処理

- 添字や指定範囲のミスで3WAもしてしまった

- 問題を単純化
  - 累乗や二項係数を使う

## 075

整数、素因数分解、操作回数の最小値

- 素因数分解
- 回数のカウント
  - 最初、ceil(sqrt())という変なことをしていた
  - 2 ** ans > 素因数分解したべき乗?の数の和
    - 部品が2つずつに分かれていくことから
- コーナーケース
  - 素数の場合は、0回

## 075

x, y軸を独立に考える、絶対値の総和の最小値、中央値を利用すると絶対値が最小に

- 発電所の座標をどこにするか?
  - mean or median
- 重複する場合は除外する?
- 整数で出力していなかった

- x, y軸の計算は独立に考えられる
- 各軸の値を計算
  - 変化量に着目する
    - f(a) = |X1 - a| + |X2 - a| + ... + |Xn - a|
    - aを+1ときの変化量は、aよりも左側にある点の個数 - aよりも右側にある点の個数
    - 左側の方の点が多いとき、左側に動く
    - 右側の方の点が多いとき、右側に動く
  - aがXの中央値のとき、絶対値の総和が最小となる

```py
    from statistics import median

# -*- coding: utf-8 -*-


def main():
    from statistics import median
    import sys

    input = sys.stdin.readline

    n = int(input())
    x = list()
    y = list()
    
    for _ in range(n):
        xi, yi = map(int, input().split())
        x.append(xi)
        y.append(yi)
    
    x_median = median(x)
    y_median = median(y)

    ans = 0

    for xi, yi in zip(x, y):
        ans += abs(x_median - xi) + abs(y_median - yi)
    
    print(int(ans))


if __name__ == "__main__":
    main()

```

## 076

整数、円環、言い換え、円環を1列に切り開いて二倍、二分探索、尺取り法

- 部分和問題→DPかと思ったが、連続する区間と書かれていたので方針変更
- 円環を切り開いて、末端を先頭にくっつける&尺取り法で数列を管理
  - 尺取り法は、dequeを使うと添字をバグらせにくいという記事を見て実装した

- 5WAが取れず
  - 単に1箇所だけ例外処理をしていただけだった
  - 2周分試したらACした

- 円環を切り開いて列として扱う
  - 二倍すると、端部を楽に処理できる
- Br - Bl = Bn / 10となる位置を二分探索
  - bisectを使った二分探索は、バグを埋め込みやすく敬遠しがち
- コーナーケース
  - 端部を含み、その区間がかなり長い場合

## 078

グラフ、隣接行列、隣接リスト

- 頂点数の分だけ配列を用意
- 頂点ai > biのときはai +=1、bi > aiのときはbi += 1
- 頂点ごとに該当する個数が1つのときだけans += 1

- リストに対してもcount()が利用できるらしい

## 079

最小操作回数、操作順に依存しない

- 最終的な結果が操作の順序に依存しないため、左上から順に操作する
- Yes/Noの判定
  - A11は、(x, y) = (1, 1)の操作でしか変えられない
  - (1, 1)の要素をvとすると、以下のように操作
    - v > 0: |v|回だけ「1減らす操作」
    - v < 0: |v|回だけ「1増やす操作」
  - A12は、(x, y) = (1, 2)の操作でしか変えられない
  - 上記の操作を繰り返す
  - 残りのH + W - 1個の要素が一致するか判定すれば良い
- 上記の判定の際の操作回数が最小操作回数になる
  - (x, y) = (i, j)の変化させる値が一意に定まるため

## 082

数列、数列の和、部分問題に分解

- 桁ごとに分解
- 右端 - 左端を求める
  - f(min(r, 10 ** i - 1)) - f(max(l, 10 ** i))
- n * (n - 1) // 2

- 数列の和
  - 1 ** 2 + 2 ** 2 + 3 ** 2 + ... + n ** 2 = n * (n + 1) * (2 * n + 1) // 6
  - 2 ** 0 + 2 ** 1 + ... + 2 ** n - 1 = 2 ** n - 1
  - 1 + p + p ** 2 + p ** 3 + ... = 1 / (1 - p) (0 < p < 1)

## 084

組み合わせ、数え上げ、ランレングス圧縮、余事象、累積和

- 条件を満たす個数を求めるのが難しい/計算量が多い場合は、条件を満たさない個数を数える
  - 全体 - 条件を満たさない個数
- 同じものはまとめる
- 区間[l, r]の選び方は、1 + 2 + 3, ..., n = n * (n - 1) / 2

## 085

約数、組み合わせ、数え上げ、約数列挙、工夫した全探索

- a, b, cは、Kの約数である
- 約数の個数は、思ったより少ない
  - 10 ** 6以下: 240個
  - 10 ** 9以下: 1344個
  - 10 ** 12以下: 6720個
  - 10 ** 18以下: 103680個
- 約数の列挙
  - √kの範囲で k % i == 0のとき、i とk // iが候補
  - setなどで重複を除去する
- a, bが決まれば、cは一意に定まる
  - c = k // (a * b)

- 約数の個数が10 ** 3程度だと思っていたが、10 ** 9のケースだった
- 列挙した約数をソート&bがaよりも大きい値のみをチェックすることで、高速化を図れる
