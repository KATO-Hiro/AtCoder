# 鉄則本

- 現状: 緑diff下位の問題なら解ける可能性がある。苦手系だと茶色上位でも怪しい。
- 目標: ABCの水色下位diffの問題が30〜45分で解けるようになる
  - 考察力を高める
  - コーナーケースを見つけられるように
- 何を重点的に学ぶか?
  - 二次元累積和
  - 尺取り法
  - 半分全列挙
  - DP
  - ビットDP
  - 余りの計算
  - 包除原理
  - ゲーム
  - 考察テクニック
  - 深さ優先探索
  - 木に対するDP
  - 演習・総合問題
    - 星3〜4を埋める

## xxx

-
- 

## 013

- 数え上げ、整数、数列、片方を固定して全探索、二分探索

- O(n ** 2)の計算量をO(nlogn)程度にしたい
- 数列は昇順になっている & 片方を固定するともう片方は、左側の要素に限定される
- 二分探索で、範囲内となるインデックスを取得
- 添字やインデックスガチャをしがちな問題
  - 範囲内 = bisect + 範囲より外側を指定
  - ペアの数なので、i - j
    - i - j + 1ではない

```py
    bisect(a, i - k - 1) # -1がポイント
```

## 018

- 部分和問題、DP

- dp[i][j]: i番目を選んだときに、合計をjにできるか?

```py
dp = [False] * (s + 1)
dp[0] = True

for ai in a:
    # 逆順に回すのがポイント
    # 配列を使い回す
    for i in range(s, 0, -1):
        if i - ai < 0:
            break

        dp[i] |= dp[i - ai]
```

## 019

- ナップサックDP

```py
for _ in range(n)
    # 上から押さえるイメージ
    for i in range(w, wi - 1, -1):
        dp[i] = max(dp[i], dp[i - wi] + vi)
```

https://atcoder.jp/contests/tessoku-book/submissions/34897562

## 031

- 整数、割り切れる数、組み合わせ、和集合

- 3で割り切れる数 + 5で割り切れる数 - 15で割り切れる数

## 065

- グラフ理論、木、木に対するDP

- 解説AC
- 実装が難しいと感じた問題
  - 親子関係を問題の制約から読み取る
  - 葉から考える
    - DFSだと思ったが、人数の更新の部分がうまく考察できず
  - 親子関係の性質から、nが大きい順に計算する
- 番号の制約がない場合は、BFSで頂点1から頂点xまでの最短経路長dist[x]を計算して、値が大きな頂点から計算する、もしくは、DFSで。

```py
    graph[ai].append(i)

    for i in range(n - 1, -1, -1):
        for j in range(len(graph[i])):
            k = graph[i][j]
            dp[i] += dp[k] + 1      

    # DFSによる解法
    def dfs(cur):
        for to in graph[cur]:
            dfs(to)
            ans[cur] += ans[to] + 1

    dfs(1)
```

- 部下→上司の方向に辺を追加すると思ったが、誤読か?

## B40

- 数え上げ、主客転倒

- mod 100が同じものを連想配列などでまとめる
- mod 100 = 0, 50のときはnC2
- それ以外は、d[i] * d[i - 100]

## A062

- グラフ、判定問題、連結、DFS、UF

- 連結性の判定 = UFで解いた
- DFS: visitedで未訪問の頂点がないか判定
