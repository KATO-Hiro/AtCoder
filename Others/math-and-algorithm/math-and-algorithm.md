# math-and-algorithm

|001-010|--|◯|◯|◯|◯|◯|◯|◯|--|◯|
|011-020|◯|◯|◯|◯|◯|◯|◯|◯|◯|◯|
|021-030|--|◯|◯|--|--|--|◯|--|◯|--|
|031-040|◯|◯|--|◯|--|--|--|◯|◯|--|
|041-050|--|--|◯|◯|--|--|--|--|--|--|
|051-060|--|--|--|--|--|--|--|--|--|--|
|061-070|--|--|--|--|--|--|--|--|--|--|
|071-080|--|--|--|--|--|--|--|--|--|--|
|081-090|--|--|--|--|--|--|--|--|--|--|
|091-100|--|--|--|--|--|--|--|--|--|--|
|101-110|--|--|--|--|--|--|--|--|--|--|

## 005

剰余

- 問題文の通り、数列Aの合計を取り、mod 100を出力

## 006

四則演算

## 007

全探索、数え上げ、剰余

## 008

全探索

## 010

階乗

## 011

素数

## 012

素数、判定

## 013

整数、約数

## 014

素因数分解

## 015

最大公約数

## 016

最大公約数、複数

- 複数の場合は、1番目の要素で初期化
- 上記の値と2番目以降の要素のgcdを求めて、答えを更新

## 017

最小公倍数、複数

- 016とほぼ同じ
- 最大公約数と最小公倍数の違いだけ

## 018

組み合わせ、数え上げ、主客転倒

- 2つの品物の合計が500円になるのを全探索するのは間に合わない
- 先に、値段ごとに該当する個数を数えておく
- 制約条件から100円と400円、200円と300円の組み合わせの合計

## 019

整数、組み合わせ、数え上げ

- 色別のカードの枚数を数える
- 色iにおけるカードの枚数をciとすると、ci * (ci - 1) // 2
- 上記の合計を取る

```python
from collections import Counter

c = Counter(a) # key, valueで管理することで楽に実装できる
```

## 020

整数、組み合わせ、数え上げ、全探索

- 5重ループで、合計が1000になるかを一つずつ判定

## 022

整数、組み合わせ、2つの和、数え上げ、主客転倒、工夫した全探索

- 018の応用問題
- 整数を1から49999まで全探索
  - もう片方は、100000から引いた値
  - 両方ともキーが存在すれば、2つの個数の積
- 50000の場合のみ特殊ケースとして扱った
  - n C 2

## 023

確率、サイコロ、期待値

## 024

期待値

- 確率 * 値

## 029

数え上げ、組み合わせ、DP

- dp[i]: i番目のときの組み合わせ数
  - dp[0] = 1 // 初期化
  - dp[i + 1] += dp[i]
  - dp[i + 2] += dp[i]

## 031

数列、価値の最大化、DP

- 1個置きに数値を選べばいいかと思っていたがWA
- DP: 直前の状態と比較
  - max(dp[i], dp[i - 1], dp[i -2] + a[i - 1])

## 032

数列、判定問題

- hoge in seqで判定


## 034

座標、2点間の距離

## 038

クエリ処理、累積和

## 039

imos法、累積和

## 043

データ構造、Union Find、連結、判定問題

- 頂点ai, biをmerge
- ある頂点の親を探して、サイズがnに等しいかどうかで判定

## 044

グラフ理論、最短距離、BFS

- ダイクストラ法(ライブラリ)で最短距離を求めたが、BFSで十分
