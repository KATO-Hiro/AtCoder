# ARC 137 B - Count 1's（1の個数） 丁寧な解説

## 📝 問題の説明（10歳児向け）

**ゲームのルール：**

- 0と1が並んだ列があります
- **1回だけ**、連続した部分を選んで、その部分を「反転」（0は1に、1は0に変える）できます
- 反転した後、全体の1がいくつになるか数えます
- **質問：いくつの異なる答えが作れますか？**

**例：** `[0, 1, 1, 0]`

- 何もしない → `[0, 1, 1, 0]` → 1が2個
- 2番目～4番目を反転 → `[0, 0, 0, 1]` → 1が1個
- 最初～最後を反転 → `[1, 0, 0, 1]` → 1が2個（同じ）
- 1番目～2番目を反転 → `[1, 0, 1, 0]` → 1が2個（同じ）

→ **作れる答え：0個, 1個, 2個, 3個** = **4種類**

---

## 🔑 重要なポイント：「最小値～最大値の間は全部作れる」

この問題の最大のコツは次の法則です：

> **反転で作れる1の個数は「最小値から最大値まで、連続している」**

つまり、最小値が2、最大値が5なら、2, 3, 4, 5 すべて作れるということです！

### なぜそんなことが言えるのか？（10歳児向け説明）

**イメージ：駅から学校への道**

- 駅（最小値）から学校（最大値）への道を考えてください
- この道は「つながっている」ので、必ず全部の地点を通ります
- なぜなら、反転する範囲を少しずつ変えることで、1の個数が少しずつ増えていくから

**具体例で説明：**

```text
元の列：[0, 1, 1, 0]
現在の1の個数：2個

反転する範囲を変えていく：
├─ 反転なし         → 1の個数 = 2
├─ 位置4だけ反転    → 1の個数 = 3 ← 1増えた！
├─ 位置3～4を反転   → 1の個数 = 2
├─ 位置2～4を反転   → 1の個数 = 1 ← 1個に減った！
└─ 位置1～4を反転   → 1の個数 = 2
```

通すとき、範囲を少しずつ広げたり狭めたりすると：

- **最小値が2のとき**、それ以上に増やそうとすると → 3, 4, 5...と増える
- **最大値が5のとき**、それ以下に減らそうとすると → 4, 3, 2...と減る
- **重要：この過程で、必ず2, 3, 4, 5 すべてを通る！**

---

## 💡 「差分」で考える（もう少し大きい子向け）

### 反転するとどうなるか？

反転する前後で、1の個数がどう変わるか見てみましょう：

```text
元の配列：[0, 1, 1, 0]
位置：     1  2  3  4
```

「位置2～3を反転」すると：

```text
元：     [0, 1, 1, 0]
反転後： [0, 0, 0, 0]
変化：   反転前に1だったものが0に (2個減る)
```

**重要な考え：**

- 反転する範囲 [L, R] を変えると
- 減少する1の個数（反転前に1だった個数）
- 増加する1の個数（反転前に0だった個数）
- が変わります

**最終的な1の個数 = 元々の1の個数 - （減った1） + （増えた1）**

### 最小値と最大値

**最小値（最も減る場合）：**

- 反転して、最も多く1が減る場合
- つまり、1が最も集中している区間を反転する

**最大値（最も増える場合）：**

- 反転して、最も多く1が増える場合
- つまり、0が最も集中している区間を反転する

---

## 🎯 なぜ「最小値～最大値間は全部作れる」のか

### キーアイデア：「変化を微調整できる」

反転する範囲を `[L, R]` から `[L, R+1]` に少し広げると：

- 位置 R+1 の値が、反転の対象に加わる
- 1の個数が、最大1だけ増える or 最大1だけ減る

例：

```text
[0, 1, 1, 0] で [1, 2] を反転 → [1, 0, 1, 0] → 1が2個

[0, 1, 1, 0] で [1, 3] を反転 → [1, 0, 0, 0] → 1が1個
                   ↑ 位置3を追加（1だから1が1個減る）

[0, 1, 1, 0] で [1, 4] を反転 → [1, 0, 0, 1] → 1が2個
                   ↑ 位置4を追加（0だから1が1個増える）
```

**つまり：**

- 範囲を少しずつ変えると、1の個数が 1個ずつ変わる
- だから、最小値から最大値まで、1個ずつ増えるパターンが必ず存在する
- 2, 3, 4, 5... と**全部通る**

---

## 📊 テスト例で確認

### 例1：`[0, 1, 1, 0]`

すべての反転パターン：

| 反転範囲 | 結果 | 1の個数 |
|---------|------|--------|
| なし | [0, 1, 1, 0] | 2 |
| [1, 1] | [1, 1, 1, 0] | 3 ✓ |
| [1, 2] | [1, 0, 1, 0] | 2 |
| [1, 3] | [1, 0, 0, 0] | 1 ✓ |
| [1, 4] | [1, 0, 0, 1] | 2 |
| [2, 2] | [0, 0, 1, 0] | 1 |
| [2, 3] | [0, 0, 0, 0] | 0 ✓ |
| [2, 4] | [0, 0, 0, 1] | 1 |
| [3, 3] | [0, 1, 0, 0] | 1 |
| [3, 4] | [0, 1, 0, 1] | 2 |
| [4, 4] | [0, 1, 1, 1] | 3 |

**作れる1の個数：0, 1, 2, 3** → **4種類** ✓

---

### 例2：`[0, 0, 0, 0, 0]`

すべて0です。

- 反転するパターン：`[0, 1, ..., 0, 0, ...]` など
- 最も多く0→1に変わる：全部反転 → 5個の1
- 最も少なく変わる：反転なし → 0個の1

**作れる1の個数：0, 1, 2, 3, 4, 5** → **6種類** ✓

---

## 🔬 解法のアルゴリズム（解く方法）

```text
1. 全ての反転パターン [L, R] を試す
   （L = 1, 2, ..., N+1 で R = L-1, L, ..., N）
   ※ [L, R] が空の場合も含む

2. 各パターンで、反転後の1の個数を計算

3. 出現した異なる個数をカウント
```

**計算量：** O(N²) または工夫で O(N)

---

## 🎓 まとめ

| 概念 | 説明 |
|-----|------|
| **反転** | 0を1に、1を0に変えること |
| **最小値** | 反転して、1が最も少なくなる場合 |
| **最大値** | 反転して、1が最も多くなる場合 |
| **連続** | 最小値から最大値の間は、全部の値が作れる |
| **答え** | 最小値～最大値の個数 = **（最大値 - 最小値 + 1）** |

---

## ❓ よくある勘違い Q&A

### Q1：main.py（ランレングスを使う方法）は何が間違っているの？

**A：** 最適な反転区間が「連続0/1だけ」とは限らないから。

#### main.py の考え方

count_max = base + 最長の連続0
count_min = base - 最長の連続1

でも実際に1の増減量が最大になるのは、**0が多くて1が少ない混合区間**を反転したときかもしれません。  
例：`[0, 0, 1, 0, 0]` だと、区間 `[0..4]` の混合（0が4個、1が1個）を反転すると増減量は `4-1=3`。  
連続0だけなら増減量は最大2です。つまり main.py は最適値を見落とします。

### Q2：累積和と「過去の極値をメモ」の関係は？

**A：** 全区間の差を O(N) で求めるため。

```python
tot = 0
for a in A:
    tot += (1 if a == 1 else -1)
    min_ = min(min_, tot)  # 過去最小をメモ
    max_ = max(max_, tot)  # 過去最大をメモ
    upp = max(upp, tot - min_)  # 区間差の最大
    low = min(low, tot - max_)  # 区間差の最小
```

- **ある区間 [l, r] の増減量** = `tot[r+1] - tot[l]`（累積和の差）
- **全区間の差の最大** = 「現在の tot から過去最小を引く」のを毎ステップ取る
- これで O(N²) 列挙を O(N) に高速化できます。

### Q3：「最小値～最大値は全部作れる」をどう証明するの？

**A：** 反転範囲を少しずつずらしても、増減量は飛び飛びにならないから。

- 区間を 1 要素広げたとき、追加される要素が 0 なら +1、1 なら -1
- つまり増減量は **1ずつしか変わらない**
- だから、最小値から最大値まで必ず**連続に**埋まります。

### Q4：main.py で「全区間」を見ていないから WA になるんですか？

**A：** はい。「最長連続0/1」という一部の区間しか見ていないのが本質的ミス。

見るべきは：

- ✅ 全区間 [l, r] に対する増減量 `(0の個数 - 1の個数)` の最大・最小
- ❌ 「連続0だけ」「連続1だけ」という特殊な区間だけ

正解コードは累積和＆過去極値メモで「全区間」を O(N) で正しく追跡します。
