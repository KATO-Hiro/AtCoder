# math-and-algorithm

|001-010|--|◯|◯|◯|◯|◯|◯|◯|◯|◯|
|011-020|◯|◯|◯|◯|◯|◯|◯|◯|◯|◯|
|021-030|◯|◯|◯|--|◯|--|◯|--|◯|--|
|031-040|◯|◯|--|◯|--|--|--|◯|◯|--|
|041-050|◯|--|◯|◯|--|--|--|--|--|◯|
|051-060|--|--|◯|--|--|--|--|--|◯|--|
|061-070|--|--|--|◯|--|--|--|--|--|--|
|071-080|--|--|--|--|--|--|--|--|--|--|
|081-090|--|--|--|--|◯|--|◯|--|--|--|
|091-100|◯|--|--|--|--|--|--|--|--|--|
|101-110|--|--|--|--|--|--|--|--|--|--|

## 005

剰余

- 問題文の通り、数列Aの合計を取り、mod 100を出力

## 006

四則演算

## 007

全探索、数え上げ、剰余

## 008

全探索

## 009

部分和問題、判定問題、再帰関数、DP、2値をbitで管理

- いろいろな解法がある問題
- 自分はDPで解いた
  - dp[i][j]: i番目の要素までの和がjになるかどうか
    - 遷移: ai番目の要素を選択するかどうか
      - 選択しない: dp[i][j] = dp[i - 1][j]
      - 選択する: dp[i][j + a[i]] = dp[i - 1][j] (ただし、j + a[i]はS以下)
  
- 実装上の工夫
  - dpのjを降順に走査することで、元の配列を使い回せる
    - 詳しい原理はよくわかっていない
  - 元の配列を最大サイズの2倍程度取ると、配列外参照を気にせずに済む

```py
    bits = 1

    for ai in a:
        bits |= bits << ai  # 論理和 & 左シフト = DPの遷移
    
    if bits >> s & 1:
        print('Yes')
    else:
        print('No')
```

## 010

階乗

## 011

素数

## 012

素数、判定

## 013

整数、約数

## 014

素因数分解

## 015

最大公約数

## 016

最大公約数、複数

- 複数の場合は、1番目の要素で初期化
- 上記の値と2番目以降の要素のgcdを求めて、答えを更新

## 017

最小公倍数、複数

- 016とほぼ同じ
- 最大公約数と最小公倍数の違いだけ

## 018

組み合わせ、数え上げ、主客転倒

- 2つの品物の合計が500円になるのを全探索するのは間に合わない
- 先に、値段ごとに該当する個数を数えておく
- 制約条件から100円と400円、200円と300円の組み合わせの合計

## 019

整数、組み合わせ、数え上げ

- 色別のカードの枚数を数える
- 色iにおけるカードの枚数をciとすると、ci * (ci - 1) // 2
- 上記の合計を取る

```python
from collections import Counter

c = Counter(a) # key, valueで管理することで楽に実装できる
```

## 020

整数、組み合わせ、数え上げ、全探索

- 5重ループで、合計が1000になるかを一つずつ判定

## 022

整数、組み合わせ、2つの和、数え上げ、主客転倒、工夫した全探索

- 018の応用問題
- 整数を1から49999まで全探索
  - もう片方は、100000から引いた値
  - 両方ともキーが存在すれば、2つの個数の積
- 50000の場合のみ特殊ケースとして扱った
  - n C 2

## 023

確率、サイコロ、期待値

## 024

期待値

- 確率 * 値

## 025

期待値

- 1日ごとに独立して計算
  - サイコロが6面あり、1と2の面が出たときはA時間の勉強を、それ以外の面が出たときはB時間勉強することを選択
  - 確率 (2 / 6) * A時間勉強 + (4 / 6) * B時間勉強

## 029

数え上げ、組み合わせ、DP

- dp[i]: i番目のときの組み合わせ数
  - dp[0] = 1 // 初期化
  - dp[i + 1] += dp[i]
  - dp[i + 2] += dp[i]

## 031

数列、価値の最大化、DP

- 1個置きに数値を選べばいいかと思っていたがWA
- DP: 直前の状態と比較
  - max(dp[i], dp[i - 1], dp[i -2] + a[i - 1])

## 032

数列、判定問題

- hoge in seqで判定


## 034

座標、2点間の距離

## 038

クエリ処理、累積和

## 039

imos法、累積和

## 041

imos法

- 入力と出力のサイズと間違えてRE

## 043

データ構造、Union Find、連結、判定問題

- 頂点ai, biをmerge
- ある頂点の親を探して、サイズがnに等しいかどうかで判定

## 044

グラフ理論、最短距離、BFS

- ダイクストラ法(ライブラリ)で最短距離を求めたが、BFSで十分

## 053

- 等比数列の和、mod、逆元、フェルマーの小定理
- ◯: 等比数列の和を求める数式を導出
- △: modの世界で考えるべきところを普通に割り算してしまった
  - 逆元を考えることで、掛け算の形に変換
  - a * a ** (p - 2) ≡ 1 (mod p)

https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-4-fermat-%E3%81%AE%E5%B0%8F%E5%AE%9A%E7%90%86%E3%81%AB%E3%82%88%E3%82%8B%E9%80%86%E5%85%83%E8%A8%88%E7%AE%97

## 064

判定問題、操作回数、ちょうどk回

- 2回の操作で、増減を0にできる
- aiの合計がk以下、かつ、k % 2 == sum(ai) % 2のときのみYes

## 085

整数、判定問題、工夫した全探索

- 一つの変数を制約条件から求める
- 1 <= d <= nの条件を忘れていて1WA

## 087

整数、剰余、高速化

- 連続する値の和を高速に求める
  - i, jともに高速化が必要
  - k * (k + 1) // 2で求めることができる

## 091

数え上げ、組み合わせ、全探索

- 制約が小さいので、全探索するだけで良い
