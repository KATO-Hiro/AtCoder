# math-and-algorithm

|001-010|--|◯|◯|◯|◯|◯|◯|◯|◯|◯|
|011-020|◯|◯|◯|◯|◯|◯|◯|◯|◯|◯|
|021-030|◯|◯|◯|--|◯|△|◯|--|◯|--|
|031-040|◯|◯|--|◯|--|--|--|◯|◯|--|
|041-050|◯|--|◯|◯|--|--|△|--|◯|◯|
|051-060|--|--|◯|--|--|--|--|◯|◯|--|
|061-070|--|--|--|◯|--|△|--|--|--|--|
|071-080|--|--|△|◯|◯|--|--|--|--|--|
|081-090|--|--|--|--|◯|--|◯|--|--|--|
|091-100|◯|--|--|--|--|--|--|--|--|--|
|101-110|--|--|--|--|--|--|--|--|--|--|

## 005

剰余

- 問題文の通り、数列Aの合計を取り、mod 100を出力

## 006

四則演算

## 007

全探索、数え上げ、剰余

## 008

全探索

## 009

部分和問題、判定問題、再帰関数、DP、2値をbitで管理

- いろいろな解法がある問題
- 自分はDPで解いた
  - dp[i][j]: i番目の要素までの和がjになるかどうか
    - 遷移: ai番目の要素を選択するかどうか
      - 選択しない: dp[i][j] = dp[i - 1][j]
      - 選択する: dp[i][j + a[i]] = dp[i - 1][j] (ただし、j + a[i]はS以下)
  
- 実装上の工夫
  - dpのjを降順に走査することで、元の配列を使い回せる
    - 詳しい原理はよくわかっていない
  - 元の配列を最大サイズの2倍程度取ると、配列外参照を気にせずに済む

```py
    bits = 1

    for ai in a:
        bits |= bits << ai  # 論理和 & 左シフト = DPの遷移
    
    if bits >> s & 1:
        print('Yes')
    else:
        print('No')
```

## 010

階乗

## 011

素数

## 012

素数、判定

## 013

整数、約数

## 014

素因数分解

## 015

最大公約数

## 016

最大公約数、複数

- 複数の場合は、1番目の要素で初期化
- 上記の値と2番目以降の要素のgcdを求めて、答えを更新

## 017

最小公倍数、複数

- 016とほぼ同じ
- 最大公約数と最小公倍数の違いだけ

## 018

組み合わせ、数え上げ、主客転倒

- 2つの品物の合計が500円になるのを全探索するのは間に合わない
- 先に、値段ごとに該当する個数を数えておく
- 制約条件から100円と400円、200円と300円の組み合わせの合計

## 019

整数、組み合わせ、数え上げ

- 色別のカードの枚数を数える
- 色iにおけるカードの枚数をciとすると、ci * (ci - 1) // 2
- 上記の合計を取る

```python
from collections import Counter

c = Counter(a) # key, valueで管理することで楽に実装できる
```

## 020

整数、組み合わせ、数え上げ、全探索

- 5重ループで、合計が1000になるかを一つずつ判定

## 022

整数、組み合わせ、2つの和、数え上げ、主客転倒、工夫した全探索

- 018の応用問題
- 整数を1から49999まで全探索
  - もう片方は、100000から引いた値
  - 両方ともキーが存在すれば、2つの個数の積
- 50000の場合のみ特殊ケースとして扱った
  - n C 2

## 023

確率、サイコロ、期待値

## 024

期待値

- 確率 * 値

## 025

期待値

- 1日ごとに独立して計算
  - サイコロが6面あり、1と2の面が出たときはA時間の勉強を、それ以外の面が出たときはB時間勉強することを選択
  - 確率 (2 / 6) * A時間勉強 + (4 / 6) * B時間勉強

## 026

- 期待値、期待値の線型性、シンプルな期待値の和に分解、dp

- 確率pで成功するチャレンジが初めて成功するまでの回数の期待値は、1/p
- 1種類目が出るまでの回数 + 2種類目が出るまでの回数 + ...
  - 具体的な値を区別する必要はない

https://www.creativ.xyz/expected-value/

## 029

数え上げ、組み合わせ、DP

- dp[i]: i番目のときの組み合わせ数
  - dp[0] = 1 // 初期化
  - dp[i + 1] += dp[i]
  - dp[i + 2] += dp[i]

## 031

数列、価値の最大化、DP

- 1個置きに数値を選べばいいかと思っていたがWA
- DP: 直前の状態と比較
  - max(dp[i], dp[i - 1], dp[i -2] + a[i - 1])

## 032

数列、判定問題

- hoge in seqで判定


## 034

座標、2点間の距離

## 038

クエリ処理、累積和

## 039

imos法、累積和

## 041

imos法

- 入力と出力のサイズと間違えてRE

## 043

データ構造、Union Find、連結、判定問題

- 頂点ai, biをmerge
- ある頂点の親を探して、サイズがnに等しいかどうかで判定

## 044

グラフ理論、最短距離、BFS

- ダイクストラ法(ライブラリ)で最短距離を求めたが、BFSで十分

## 047

グラフ理論、二部グラフ、判定問題、DFS

- drkenさんの記事を読んで、Pythonで実装しただけ

- 色の割り当てをdfs
  - NG: すでに訪問済み、かつ、同じ色を塗る
  - NG: dfsで1回でもNGが発生する
  - OK: それ以外

https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-3-%E4%BA%8C%E9%83%A8%E3%82%B0%E3%83%A9%E3%83%95%E5%88%A4%E5%AE%9A

## 049

数列、フィボナッチ数列

- ループで愚直に計算
- swapすると短く記述できる

## 053

- 等比数列の和、mod、逆元、フェルマーの小定理
- ◯: 等比数列の和を求める数式を導出
- △: modの世界で考えるべきところを普通に割り算してしまった
  - 逆元を考えることで、掛け算の形に変換
  - a * a ** (p - 2) ≡ 1 (mod p)

https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-4-fermat-%E3%81%AE%E5%B0%8F%E5%AE%9A%E7%90%86%E3%81%AB%E3%82%88%E3%82%8B%E9%80%86%E5%85%83%E8%A8%88%E7%AE%97

## 058

グリッド、判定問題、偶奇

- ◯: xとyの絶対値の和の偶奇がn (mod 2)と一致すればYes
- △: x + y <= nのときが抜けていた

- 最終的な形にするときに、所定の操作が必要な回数だけ実行できるか確認

## 064

判定問題、操作回数、ちょうどk回

- 2回の操作で、増減を0にできる
- aiの合計がk以下、かつ、k % 2 == sum(ai) % 2のときのみYes

## 066

数え上げ、組み合わせ、絶対値の差、工夫した全探索

- ◯: 制約のkが小さいので、全体 - 条件を満たさない場合とすれば良さそう
- △: 探索範囲を間違えていた
  - lowerとupperを設定する必要がある
  - iに対して、k未満となる範囲 & [1, n]の範囲に収まるように
    - 最小値: max(1, i - k + 1)
    - 最大値: max(n + 1, i + k)
- △: abs(j - k) < kのみ判定すればよかった
  - iとj、iとkに対しては、範囲を満たしているため

- 探索範囲をミスしがち

## 073

数え上げ、合計、剰余

- 誤読していた
  - 2 ** n - 1通りの選び方のうち、「選んだ整数の最大値」が理解できていなかった
    - ある選び方を見たときに、最大の整数を合計に加算
  - 樹形図を書けば題意を理解できたと思う
    - ◯の位置にある数字が選択される = 2べきで増えていく

## 074

数列、総和、累積和

- iを固定して、加算される部分と減算される部分を分ける & まとめて計算
- 加算部分は累積和で前計算しておく
- (2 * i + 1 - n) * a[i]の総和と天才的な解法も

## 075

組み合わせ、パスカルの三角形、二項係数、剰余

- 繰り返し加算される部分が、パスカルの三角形になっている
  - この部分に気がつくのに時間が掛かった
- modが取れるnCrライブラリで係数が取れる
- a[i]に係数を順番に掛けるだけ

## 085

整数、判定問題、工夫した全探索

- 一つの変数を制約条件から求める
- 1 <= d <= nの条件を忘れていて1WA

## 087

整数、剰余、高速化

- 連続する値の和を高速に求める
  - i, jともに高速化が必要
  - k * (k + 1) // 2で求めることができる

## 091

数え上げ、組み合わせ、全探索

- 制約が小さいので、全探索するだけで良い
